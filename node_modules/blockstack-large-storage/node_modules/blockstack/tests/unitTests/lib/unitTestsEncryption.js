'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runEncryptionTests = runEncryptionTests;

var _tape = require('tape-promise/tape');

var _tape2 = _interopRequireDefault(_tape);

var _encryption = require('../../../lib/encryption');

var _elliptic = require('elliptic');

var _elliptic2 = _interopRequireDefault(_elliptic);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function runEncryptionTests() {
  var privateKey = 'a5c61c6ca7b3e7e55edee68566aeab22e4da26baa285c7bd10e8d2218aa3b229';
  var publicKey = '027d28f9951ce46538951e3697c62588a87f1f1f295de4a14fdd4c780fc52cfe69';

  (0, _tape2.default)('encrypt-to-decrypt works', function (t) {
    t.plan(2);

    var testString = 'all work and no play makes jack a dull boy';
    var cipherObj = (0, _encryption.encryptECIES)(publicKey, testString);
    var deciphered = (0, _encryption.decryptECIES)(privateKey, cipherObj);
    t.equal(deciphered, testString, 'Decrypted ciphertext does not match expected plaintext');

    var testBuffer = new Buffer(testString);
    cipherObj = (0, _encryption.encryptECIES)(publicKey, testBuffer);
    deciphered = (0, _encryption.decryptECIES)(privateKey, cipherObj);
    t.equal(deciphered.toString('hex'), testBuffer.toString('hex'), 'Decrypted cipherbuffer does not match expected plainbuffer');
  });

  (0, _tape2.default)('encrypt-to-decrypt fails on bad mac', function (t) {
    t.plan(1);

    var testString = 'all work and no play makes jack a dull boy';
    var cipherObj = (0, _encryption.encryptECIES)(publicKey, testString);
    var evilString = 'some work and some play makes jack a dull boy';
    var evilObj = (0, _encryption.encryptECIES)(publicKey, evilString);

    cipherObj.cipherText = evilObj.cipherText;

    try {
      (0, _encryption.decryptECIES)(privateKey, cipherObj);
      t.true(false, 'Decryption should have failed when ciphertext modified');
    } catch (e) {
      t.true(true, 'Decryption correctly fails when ciphertext modified');
    }
  });

  (0, _tape2.default)('bn-padded-to-64-bytes', function (t) {
    t.plan(1);
    var ecurve = new _elliptic2.default.ec('secp256k1');

    var evilHexes = ['ba40f85b152bea8c3812da187bcfcfb0dc6e15f9e27cb073633b1c787b19472f', 'e346010f923f768138152d0bad063999ff1da5361a81e6e6f9106241692a0076'];
    var results = evilHexes.map(function (hex) {
      var ephemeralSK = ecurve.keyFromPrivate(hex);
      var ephemeralPK = ephemeralSK.getPublic();
      var sharedSecret = ephemeralSK.derive(ephemeralPK);
      return (0, _encryption.getHexFromBN)(sharedSecret).length === 64;
    });

    t.true(results.every(function (x) {
      return x;
    }), 'Evil hexes must all generate 64-len hex strings');
  });
}