<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" latency-monitor Classes LatencyMonitormodule.exportsVisibilityChangeEmitter Global isVisible Global Methods isVisible() The function returns true if the page is visible or false if the page is not visible and undefined if the page visibility API is not supported by the browser. Returns: whether the page is now visible or not (undefined is unknown) Type Boolean | void Type Definitions SummaryObject Type: Object Properties: Name Type Description events Number How many events were called minMS Number What was the min time for a cb to be called maxMS Number What was the max time for a cb to be called avgMs Number What was the average time for a cb to be called lengthMs Number How long this interval was in ms × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 6:19:44 pm using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" latency-monitor Classes LatencyMonitormodule.exportsVisibilityChangeEmitter Global isVisible Classes Classes LatencyMonitor exports VisibilityChangeEmitter × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 6:19:44 pm using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" latency-monitor Classes LatencyMonitormodule.exportsVisibilityChangeEmitter Global isVisible latency-monitor A monitor that periodically times how long it takes for a callback to be called. Think event loop latency. UsageThis tool allows you to time and get summaries of how long async functions took. By default, it assumes you want to measure event loop latency, but as this example shows, you can use it for a simple ping pong setup with Promises too. This code works in both browsers and node.js and will do its best effort to use as accurate a timer as possible. Example event loop monitor (default). import LatencyMonitor from 'latency-monitor'; const monitor = new LatencyMonitor(); console.log('Event Loop Latency Monitor Loaded: %O', { latencyCheckIntervalMs: monitor.latencyCheckIntervalMs, dataEmitIntervalMs: monitor.dataEmitIntervalMs }); monitor.on('data', (summary) =&gt; console.log('Event Loop Latency: %O', summary)); /* * In console you will see something like this: * Event Loop Latency Monitor Loaded: * {dataEmitIntervalMs: 5000, latencyCheckIntervalMs: 500} * Event Loop Latency: * {avgMs: 3, events: 10, maxMs: 5, minMs: 1, lengthMs: 5000} */More TheoryWe use setTimeout to pick when to run the next test. We do this so we can add in some randomness to avoid aligning our events with some external event (e.g. another timer that triggers a slow event). When we are monitoring event loop latency (i.e. no async function provided), then we simply record how long getting the callback really took. When we measure an async function, we only time how long that async function took to call the passed in cb. When used in a browser, this tool disables itself if the page is hidden because of restrictions with how often we can call setTimeout see this. When monitoring event loop latency, we add in 1ms to all measurements. setTimeout is not more accurate than 1ms, so this ensures every number is greater than 0. To remove this offset, simply subtract 1 from all stats. TLDR; event loop latency monitoring does NOT have sub-millisecond accuracy, even if the emitted numbers show this. InstallationInstall latency-monitor as a dependency: npm install --save latency-monitorOn Demand Browser LatencyWe also host a copy of the browser event loop latency detector on jsdelivr. To use this, you can include the script in a src tag, or simply load it in Chrome DevTools. You should expect to see the same output as documented above in usage. Load via script element (paste into page's html): &lt;script src='//cdn.jsdelivr.net/latency-monitor/0.2.1/EventLoopPrinterWebpacked.js'&gt;&lt;/script&gt;Load via script in JavaScript (paste in your devtools - e.g. Chrome DevTools): var el = document.createElement('script'); el.setAttribute('src', 'https://cdn.jsdelivr.net/latency-monitor/0.2.1/EventLoopPrinterWebpacked.js') document.body.appendChild(el)Load via jquery (if you have $ loaded on the page already, paste this in Chrome DevTools or in your code): $.getScript('//cdn.jsdelivr.net/latency-monitor/0.2.1/EventLoopPrinterWebpacked.js');Last resort: Load via XMLHTTPRequest: var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;//cdn.jsdelivr.net/latency-monitor/0.2.1/EventLoopPrinterWebpacked.js&quot;, true); xhr.onreadystatechange = function() { if (xhr.readyState == 4) { // WARNING! Might be evaluating an evil script! var resp = eval(xhr.responseText); } }; xhr.send();Note: Remember to change 0.2.1 above to whatever is the latest version of latency-monitor. DebuggingWe use debug. In node set env variable DEBUG=latency-monitor:* or in a browser localStorage.debug='latency-monitor' to see debugging output. NotesThis is a reasonable attempt to make a latency monitor. There are issues such as: We don't wait for the last event to finish when emitting stats. This means if the last event in a cycle takes the longest, or is never returned, then for that cycle large latency isn't recorded. LicenseApache-2.0 License × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 6:19:44 pm using the DocStrap template. "},"LatencyMonitor.html":{"id":"LatencyMonitor.html","title":"Class: LatencyMonitor","body":" latency-monitor Classes LatencyMonitormodule.exportsVisibilityChangeEmitter Global isVisible Class: LatencyMonitor LatencyMonitor A class to monitor latency of any async function which works in a browser or node. This works by periodically calling the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this. This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0. The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop and timing how long it takes to get back. new LatencyMonitor( [latencyCheckIntervalMs] [, dataEmitIntervalMs] [, asyncTestFn] [, latencyRandomPercentage]) Parameters: Name Type Argument Default Description latencyCheckIntervalMs Number &lt;optional&gt; 500 How often to add a latency check event (ms) dataEmitIntervalMs Number &lt;optional&gt; 5000 How often to summarize latency check events. null or 0 disables event firing asyncTestFn function &lt;optional&gt; What cb-style async function to use latencyRandomPercentage Number &lt;optional&gt; 5 What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events. Examples const monitor = new LatencyMonitor(); monitor.on('data', (summary) =&gt; console.log('Event Loop Latency: %O', summary)); const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping}); monitor.on('data', (summary) =&gt; console.log('Ping Pong Latency: %O', summary)); Methods getSummary() Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue, it will not count for this time period Returns: Type SummaryObject × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 6:19:44 pm using the DocStrap template. "},"module.exports.html":{"id":"module.exports.html","title":"Class: exports","body":" latency-monitor Classes LatencyMonitormodule.exportsVisibilityChangeEmitter Global isVisible Class: exports exports new exports() Creates a VisibilityChangeEmitter × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 6:19:44 pm using the DocStrap template. "},"VisibilityChangeEmitter.html":{"id":"VisibilityChangeEmitter.html","title":"Class: VisibilityChangeEmitter","body":" latency-monitor Classes LatencyMonitormodule.exportsVisibilityChangeEmitter Global isVisible Class: VisibilityChangeEmitter VisibilityChangeEmitter new VisibilityChangeEmitter() Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter. Warning: This does not work on all browsers, but should work on all modern browsers Example const myVisibilityEmitter = new VisibilityChangeEmitter(); myVisibilityEmitter.on('visibilityChange', (pageInFocus) =&gt; { if ( pageInFocus ){ // Page is in focus console.log('In focus'); } else { // Page is blurred console.log('Out of focus'); } }); // To access the visibility state directly, call: console.log('Am I focused now? ' + myVisibilityEmitter.isVisible()); × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 6:19:44 pm using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
