'use strict';

exports.__esModule = true;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _element = require('handsontable/helpers/dom/element');

var _object = require('handsontable/helpers/object');

var _data = require('handsontable/helpers/data');

var _plugins = require('handsontable/plugins');

var _base = require('handsontable/plugins/_base');

var _base2 = _interopRequireDefault(_base);

var _dateCalculator = require('./dateCalculator');

var _dateCalculator2 = _interopRequireDefault(_dateCalculator);

var _ganttChartDataFeed = require('./ganttChartDataFeed');

var _ganttChartDataFeed2 = _interopRequireDefault(_ganttChartDataFeed);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @plugin GanttChart
 * @pro
 * @experimental
 * @dependencies CollapsibleColumns
 *
 * @description
 * GanttChart plugin enables a possibility to create a Gantt chart using a Handsontable instance.
 * In this case, the whole table becomes read-only.
 *
 * @example
 * ```js
 * ganttChart: {
 *     dataSource: data,
 *     firstWeekDay: 'monday', // sets the first day of the week to either 'monday' or 'sunday'
 *     startYear: 2015 // sets the displayed year to the provided value
 *     weekHeaderGenerator: function(start, end) { return start + ' - ' + end; } // sets the label on the week column headers (optional). The `start` and `end` arguments are numbers representing the beginning and end day of the week.
 *   }
 *
 * // Where data can be either an data object or an object containing information about another Handsontable instance, which
 * // would feed the chart-enabled instance with data.
 * // For example:
 *
 * // Handsontable-binding information
 * var data = {
 *   instance: source, // reference to another Handsontable instance
 *   startDateColumn: 4, // index of a column, which contains information about start dates of data ranges
 *   endDateColumn: 5, // index of a column, which contains information about end dates of data ranges
 *   additionalData: { // information about additional data passed to the chart, in this example example:
 *     label: 0, // labels are stored in the first column
 *     quantity: 1 // quantity information is stored in the second column
 *   },
 *   allowSplitWeeks: true, // If set to `true` (default), will allow splitting week columns between months. If not, plugin will generate "mixed" months, like "Jan/Feb"
 *   asyncUpdates: true // if set to true, the updates from the source instance with be asynchronous. Defaults to false.
 * }
 *
 * // Data object
 * var data = [
 *   {
 *     additionalData: {label: 'Example label.', quantity: 'Four packs.'},
 *     startDate: '1/5/2015',
 *     endDate: '1/20/2015'
 *   },
 *   {
 *     additionalData: {label: 'Another label.', quantity: 'One pack.'},
 *     startDate: '1/11/2015',
 *     endDate: '1/29/2015'
 *   }
 * ];
 * ```
 */
var GanttChart = function (_BasePlugin) {
  _inherits(GanttChart, _BasePlugin);

  function GanttChart(hotInstance) {
    _classCallCheck(this, GanttChart);

    /**
     * Cached plugin settings.
     *
     * @type {Object}
     */
    var _this = _possibleConstructorReturn(this, (GanttChart.__proto__ || Object.getPrototypeOf(GanttChart)).call(this, hotInstance));

    _this.settings = {};
    /**
     * Date Calculator object.
     *
     * @type {Object}
     */
    _this.dateCalculator = null;
    /**
     * Currently loaded year.
     *
     * @type {Number}
     */
    _this.currentYear = null;
    /**
     * List of months and their corresponding day counts.
     *
     * @type {Array}
     */
    _this.monthList = [];
    /**
     * Array of data for the month headers.
     *
     * @type {Array}
     */
    _this.monthHeadersArray = [];
    /**
     * Array of data for the week headers.
     *
     * @type {Array}
     */
    _this.weekHeadersArray = [];
    /**
     * Object containing the currently created range bars, along with their corresponding parameters.
     *
     * @type {Object}
     */
    _this.rangeBars = {};
    /**
     * Object containing the currently created ranges with coordinates to their range bars.
     *
     * @type {Object}
     */
    _this.rangeList = {};
    /**
     * Reference to the Nested Headers plugin.
     *
     * @type {Object}
     */
    _this.nestedHeadersPlugin = null;

    /**
     * Object containing properties of the source Handsontable instance (the data source).
     *
     * @type {Object}
     */
    _this.hotSource = null;
    /**
     * Number of week 'blocks' in the nested headers.
     *
     * @type {Number}
     */
    _this.overallWeekSectionCount = null;
    /**
     * Initial instance settings - used to rollback the gantt-specific settings during the disabling of the plugin.
     *
     * @type {Object}
     */
    _this.initialSettings = null;
    /**
     * Data feed controller for this plugin.
     *
     * @type {Object}
     */
    _this.dataFeed = null;
    /**
     * Color information set after applying colors to the chart.
     *
     * @type {Object}
     */
    _this.colorData = {};
    /**
     * Metadata of the range bars, used to re-apply meta after updating HOT settings.
     *
     * @type {Object}
     */
    _this.rangeBarMeta = Object.create(null);
    return _this;
  }

  /**
   * Check if the dependencies are met, if not, throws a warning.
   */


  _createClass(GanttChart, [{
    key: 'checkDependencies',
    value: function checkDependencies() {
      if (!this.hot.getSettings().colHeaders) {
        console.warn('You need to enable the colHeaders property in your Gantt Chart Handsontable in order for it to work properly.');
      }
    }

    /**
     * Check if plugin is enabled
     */

  }, {
    key: 'isEnabled',
    value: function isEnabled() {
      return !!this.hot.getSettings().ganttChart;
    }

    /**
     * Enable the plugin
     */

  }, {
    key: 'enablePlugin',
    value: function enablePlugin() {
      var _this2 = this;

      if (this.enabled) {
        return;
      }

      this.checkDependencies();

      this.parseSettings();

      this.currentYear = this.settings.startYear || new Date().getFullYear();

      this.dateCalculator = new _dateCalculator2.default(this.currentYear, this.settings.allowSplitWeeks);
      this.dateCalculator.setFirstWeekDay(this.settings.firstWeekDay);

      this.monthList = this.dateCalculator.getMonthList();
      this.monthHeadersArray = this.generateMonthHeaders();
      this.weekHeadersArray = this.generateWeekHeaders();

      this.overallWeekSectionCount = this.dateCalculator.countWeekSections();

      this.assignGanttSettings();

      if (this.nestedHeadersPlugin) {
        this.applyDataSource();

        if (this.colorData) {
          this.setRangeBarColors(this.colorData);
        }
      }

      this.addHook('afterInit', function () {
        return _this2.onAfterInit();
      });

      (0, _element.addClass)(this.hot.rootElement, 'ganttChart');

      _get(GanttChart.prototype.__proto__ || Object.getPrototypeOf(GanttChart.prototype), 'enablePlugin', this).call(this);
    }

    /**
     * Disable the plugin.
     */

  }, {
    key: 'disablePlugin',
    value: function disablePlugin() {
      if (this.internalUpdateSettings) {
        return;
      }

      if (this.dataFeed && this.dataFeed.hotSource) {
        this.dataFeed.removeSourceHotHooks(this.dataFeed.hotSource);
      }

      this.settings = {};
      this.dataFeed = {};
      this.currentYear = null;
      this.monthList = [];
      this.rangeBars = {};
      this.rangeList = {};
      this.rangeBarMeta = {};
      this.hotSource = null;

      this.deassignGanttSettings();

      this.hot.getPlugin('collapsibleColumns').disablePlugin();
      this.hot.getPlugin('nestedHeaders').disablePlugin();

      (0, _element.removeClass)(this.hot.rootElement, 'ganttChart');

      _get(GanttChart.prototype.__proto__ || Object.getPrototypeOf(GanttChart.prototype), 'disablePlugin', this).call(this);
    }

    /**
     * Updates the plugin to use the latest options you have specified.
     */

  }, {
    key: 'updatePlugin',
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();

      _get(GanttChart.prototype.__proto__ || Object.getPrototypeOf(GanttChart.prototype), 'updatePlugin', this).call(this);
    }

    /**
     * Parse the plugin settings.
     */

  }, {
    key: 'parseSettings',
    value: function parseSettings() {
      this.settings = this.hot.getSettings().ganttChart;

      if (typeof this.settings === 'boolean') {
        this.settings = {};
      }

      if (!this.settings.firstWeekDay) {
        this.settings.firstWeekDay = 'monday';
      }

      if (this.settings.allowSplitWeeks === void 0) {
        this.settings.allowSplitWeeks = true;
      }

      if (typeof this.settings.weekHeaderGenerator !== 'function') {
        this.settings.weekHeaderGenerator = null;
      }
    }

    /**
     * Apply the data source provided in the plugin settings.
     *
     * @private
     */

  }, {
    key: 'applyDataSource',
    value: function applyDataSource() {
      if (this.settings.dataSource) {
        var source = this.settings.dataSource;

        if (source.instance) {
          this.loadData(source.instance, source.startDateColumn, source.endDateColumn, source.additionalData, source.asyncUpdates);
        } else {
          this.loadData(source);
        }
      }
    }

    /**
     * Load chart data to the Handsontable instance.
     *
     * @private
     * @param {Array|Object} data Array of objects containing the range data OR another Handsontable instance, to be used as the data feed
     * @param {Number} [startDateColumn] Index of the start date column (Needed only if the data argument is a HOT instance).
     * @param {Number} [endDateColumn] Index of the end date column (Needed only if the data argument is a HOT instance).
     * @param {Object} [additionalData] Object containing additional data labels and their corresponding column indexes (Needed only if the data argument is a HOT instance).
     *
     */

  }, {
    key: 'loadData',
    value: function loadData(data, startDateColumn, endDateColumn, additionalData, asyncUpdates) {
      if (data.length > 1) {
        this.hot.alter('insert_row', 0, data.length - 1, this.pluginName + '.loadData');
      }

      this.dataFeed = new _ganttChartDataFeed2.default(this.hot, data, startDateColumn, endDateColumn, additionalData, asyncUpdates);

      this.hot.render();
    }

    /**
     * Clear the range bars list.
     *
     * @private
     */

  }, {
    key: 'clearRangeBars',
    value: function clearRangeBars() {
      this.rangeBars = {};
    }

    /**
     * Clear the range list.
     *
     * @private
     */

  }, {
    key: 'clearRangeList',
    value: function clearRangeList() {
      this.rangeList = {};
    }

    /**
     * Get a range bar coordinates by the provided row.
     *
     * @param {Number} row Range bar's row.
     * @returns {Object}
     */

  }, {
    key: 'getRangeBarCoordinates',
    value: function getRangeBarCoordinates(row) {
      return this.rangeList[row];
    }

    /**
     * Generate headers for the year structure.
     *
     * @private
     * @param {String} type Granulation type ('months'/'weeks'/'days')
     */

  }, {
    key: 'generateHeaderSet',
    value: function generateHeaderSet(type) {
      var _this3 = this;

      var weekHeaderGenerator = this.settings.weekHeaderGenerator;
      var headers = [];

      (0, _object.objectEach)(this.monthList, function (month, index) {
        var areDaysBeforeFullWeeks = month.daysBeforeFullWeeks > 0 ? 1 : 0;
        var areDaysAfterFullWeeks = month.daysAfterFullWeeks > 0 ? 1 : 0;
        var headerCount = month.fullWeeks + (_this3.settings.allowSplitWeeks ? areDaysBeforeFullWeeks + areDaysAfterFullWeeks : 0);
        var monthNumber = parseInt(index, 10);
        var allowSplitWeeks = _this3.settings.allowSplitWeeks;
        var headerLabel = '';

        if (type === 'months') {
          headers.push({
            label: month.name,
            colspan: headerCount
          });
        } else if (type === 'weeks') {

          for (var i = 0; i < headerCount; i++) {
            var start = null;
            var end = null;

            // Mixed month's only column
            if (!allowSplitWeeks && month.fullWeeks === 1) {

              // Standard week column
              var _getWeekColumnRange = _this3.getWeekColumnRange(month, monthNumber, i, true);

              var _getWeekColumnRange2 = _slicedToArray(_getWeekColumnRange, 2);

              start = _getWeekColumnRange2[0];
              end = _getWeekColumnRange2[1];
            } else {
              var _getWeekColumnRange3 = _this3.getWeekColumnRange(month, monthNumber, i);

              var _getWeekColumnRange4 = _slicedToArray(_getWeekColumnRange3, 2);

              start = _getWeekColumnRange4[0];
              end = _getWeekColumnRange4[1];
            }

            if (start === end) {
              headerLabel = start;
            } else {
              headerLabel = start + ' -  ' + end;
            }

            headers.push(weekHeaderGenerator ? weekHeaderGenerator.call(_this3, start, end) : headerLabel);

            _this3.dateCalculator.addDaysToCache(monthNumber, headers.length - 1, start, end);
          }
        }
      });

      return headers;
    }

    /**
     * Get the week column range.
     *
     * @private
     * @param {Object} monthObject The month object.
     * @param {Number} monthNumber Index of the month.
     * @param {Number} headerIndex Index of the header.
     * @param {Boolean} mixedMonth `true` if the header is the single header of a mixed month.
     * @returns {Array}
     */

  }, {
    key: 'getWeekColumnRange',
    value: function getWeekColumnRange(monthObject, monthNumber, headerIndex, mixedMonth) {
      var allowSplitWeeks = this.settings.allowSplitWeeks;
      var areDaysBeforeFullWeeks = monthObject.daysBeforeFullWeeks > 0 ? 1 : 0;
      var areDaysAfterFullWeeks = monthObject.daysAfterFullWeeks > 0 ? 1 : 0;
      var headerCount = monthObject.fullWeeks + (this.settings.allowSplitWeeks ? areDaysBeforeFullWeeks + areDaysAfterFullWeeks : 0);

      var start = null;
      var end = null;

      if (mixedMonth) {
        if (monthNumber === 0) {
          end = this.monthList[monthNumber + 1].daysBeforeFullWeeks;
          start = _utils.DEC_LENGTH - (_utils.WEEK_LENGTH - end) + 1;
        } else if (monthNumber === this.monthList.length - 1) {
          end = _utils.WEEK_LENGTH - this.monthList[monthNumber - 1].daysAfterFullWeeks;
          start = this.monthList[monthNumber - 1].days - this.monthList[monthNumber - 1].daysAfterFullWeeks + 1;
        } else {
          end = this.monthList[monthNumber + 1].daysBeforeFullWeeks;
          start = this.monthList[monthNumber - 1].days - (_utils.WEEK_LENGTH - end) + 1;
        }
      } else if (allowSplitWeeks && areDaysBeforeFullWeeks && headerIndex === 0) {
        start = headerIndex + 1;
        end = monthObject.daysBeforeFullWeeks;
      } else if (allowSplitWeeks && areDaysAfterFullWeeks && headerIndex === headerCount - 1) {
        start = monthObject.days - monthObject.daysAfterFullWeeks + 1;
        end = monthObject.days;
      } else {
        start = null;
        if (allowSplitWeeks) {
          start = monthObject.daysBeforeFullWeeks + (headerIndex - areDaysBeforeFullWeeks) * _utils.WEEK_LENGTH + 1;
        } else {
          start = monthObject.daysBeforeFullWeeks + headerIndex * _utils.WEEK_LENGTH + 1;
        }
        end = start + _utils.WEEK_LENGTH - 1;
      }

      return [start, end];
    }

    /**
     * Generate the month header structure.
     *
     * @private
     */

  }, {
    key: 'generateMonthHeaders',
    value: function generateMonthHeaders() {
      return this.generateHeaderSet('months');
    }

    /**
     * Generate the week header structure.
     *
     * @private
     */

  }, {
    key: 'generateWeekHeaders',
    value: function generateWeekHeaders() {
      return this.generateHeaderSet('weeks');
    }

    /**
     * Generate the day header structure.
     *
     * @private
     */

  }, {
    key: 'generateDayHeaders',
    value: function generateDayHeaders() {
      return this.generateHeaderSet('days');
    }

    /**
     * Assign the settings needed for the Gantt Chart plugin into the Handsontable instance.
     *
     * @private
     */

  }, {
    key: 'assignGanttSettings',
    value: function assignGanttSettings() {
      var _this4 = this;

      this.initialSettings = (0, _object.deepClone)(this.hot.getSettings());

      var additionalSettings = {
        data: (0, _data.createEmptySpreadsheetData)(1, this.overallWeekSectionCount),
        readOnly: true,
        renderer: function renderer(instance, TD, row, col, prop, value, cellProperties) {
          return _this4.uniformBackgroundRenderer(instance, TD, row, col, prop, value, cellProperties);
        },
        colWidths: 60,
        hiddenColumns: true,
        nestedHeaders: [this.monthHeadersArray.slice(), this.weekHeadersArray.slice()],
        collapsibleColumns: true,
        columnSorting: false
      };

      this.internalUpdateSettings = true;
      this.hot.updateSettings(additionalSettings);
      this.internalUpdateSettings = void 0;
    }

    /**
     * Deassign the Gantt Chart plugin settings (revert to initial settings).
     *
     * @private
     */

  }, {
    key: 'deassignGanttSettings',
    value: function deassignGanttSettings() {
      this.internalUpdateSettings = true;

      if (this.initialSettings) {
        this.hot.updateSettings(this.initialSettings);
      }

      this.internalUpdateSettings = void 0;
    }

    /**
     * Add rangebar meta data to the cache.
     *
     * @param {Number} row
     * @param {Number} col
     * @param {String} key
     * @param {String|Number|Object|Array} value
     */

  }, {
    key: 'cacheRangeBarMeta',
    value: function cacheRangeBarMeta(row, col, key, value) {
      if (!this.rangeBarMeta[row]) {
        this.rangeBarMeta[row] = {};
      }

      if (!this.rangeBarMeta[row][col]) {
        this.rangeBarMeta[row][col] = {};
      }

      this.rangeBarMeta[row][col][key] = value;
    }

    /**
     * Apply the cached cell meta.
     */

  }, {
    key: 'applyRangeBarMetaCache',
    value: function applyRangeBarMetaCache() {
      var _this5 = this;

      (0, _object.objectEach)(this.rangeBarMeta, function (rowArr, row) {
        (0, _object.objectEach)(rowArr, function (cell, col) {
          (0, _object.objectEach)(cell, function (value, key) {
            _this5.hot.setCellMeta(row, col, key, value);
          });
        });
      });
    }

    /**
     * Create a new range bar.
     *
     * @param {Number} row Row index.
     * @param {Date|String} startDate Start date object/string.
     * @param {Date|String} endDate End date object/string.
     * @param {Object} additionalData Additional range data.
     * @returns {Array|Boolean} Array of the bar's row and column.
     */

  }, {
    key: 'addRangeBar',
    value: function addRangeBar(row, startDate, endDate, additionalData) {
      var _this6 = this;

      var startDateColumn = this.dateCalculator.dateToColumn(startDate);
      var endDateColumn = this.dateCalculator.dateToColumn(endDate);

      if (!this.dateCalculator.isValidRangeBarData(startDate, endDate) || startDateColumn == null || endDateColumn == null) {
        return false;
      }

      if (!this.rangeBars[row]) {
        this.rangeBars[row] = {};
      }

      this.rangeBars[row][startDateColumn] = {
        barLength: endDateColumn - startDateColumn + 1,
        partialStart: !this.dateCalculator.isOnTheEdgeOfWeek(startDate)[0],
        partialEnd: !this.dateCalculator.isOnTheEdgeOfWeek(endDate)[1],
        additionalData: {}
      };

      (0, _object.objectEach)(additionalData, function (prop, i) {
        _this6.rangeBars[row][startDateColumn].additionalData[i] = prop;
      });

      if (this.colorData[row]) {
        this.rangeBars[row][startDateColumn].colors = this.colorData[row];
      }

      this.rangeList[row] = [row, startDateColumn];

      this.renderRangeBar(row, startDateColumn, endDateColumn, additionalData);

      return [row, startDateColumn];
    }

    /**
     * Get the range bar data of the provided row and column.
     *
     * @param {Number} row Row index.
     * @param {Number} column Column index.
     * @returns {Object|Boolean} Returns false if no bar is found.
     */

  }, {
    key: 'getRangeBarData',
    value: function getRangeBarData(row, column) {
      var rangeBarCoords = this.getRangeBarCoordinates(row);

      if (!rangeBarCoords) {
        return false;
      }

      var rangeBarData = this.rangeBars[rangeBarCoords[0]][rangeBarCoords[1]];

      if (rangeBarData && row === rangeBarCoords[0] && (column === rangeBarCoords[1] || column > rangeBarCoords[1] && column < rangeBarCoords[1] + rangeBarData.barLength)) {
        return rangeBarData;
      }

      return false;
    }

    /**
     * Update the range bar data by the provided object.
     *
     * @param {Number} row Row index.
     * @param {Number} column Column index.
     * @param {Object} data Object with the updated data.
     */

  }, {
    key: 'updateRangeBarData',
    value: function updateRangeBarData(row, column, data) {
      var rangeBar = this.getRangeBarData(row, column);

      (0, _object.objectEach)(data, function (val, prop) {
        if (rangeBar[prop] !== val) {
          rangeBar[prop] = val;
        }
      });
    }

    /**
     * Add a range bar to the table.
     *
     * @param {Number} row Row index.
     * @param {Number} startDateColumn Start column index.
     * @param {Number} endDateColumn End column index.
     * @param {Object} additionalData Additional range data.
     */

  }, {
    key: 'renderRangeBar',
    value: function renderRangeBar(row, startDateColumn, endDateColumn, additionalData) {
      var currentBar = this.rangeBars[row][startDateColumn];

      for (var i = startDateColumn; i <= endDateColumn; i++) {
        var cellMeta = this.hot.getCellMeta(row, i);
        var newClassName = (cellMeta.className || '') + ' rangeBar';

        if (i === startDateColumn && currentBar.partialStart || i === endDateColumn && currentBar.partialEnd) {
          newClassName += ' partial';
        }

        if (i === endDateColumn) {
          newClassName += ' last';
        }

        this.hot.setCellMeta(row, i, 'originalClassName', cellMeta.className);
        this.hot.setCellMeta(row, i, 'className', newClassName);
        this.hot.setCellMeta(row, i, 'additionalData', currentBar.additionalData);

        // cache cell meta, used for updateSettings, related with a cell meta bug
        this.cacheRangeBarMeta(row, i, 'originalClassName', cellMeta.className);
        this.cacheRangeBarMeta(row, i, 'className', newClassName);
        this.cacheRangeBarMeta(row, i, 'additionalData', currentBar.additionalData);
      }
    }

    /**
     * Remove a range bar of the provided start date and row.
     *
     * @param {Number} row Row index.
     * @param {Date|String} startDate Start date.
     */

  }, {
    key: 'removeRangeBarByDate',
    value: function removeRangeBarByDate(row, startDate) {
      var startDateColumn = this.dateCalculator.dateToColumn(startDate);

      this.removeRangeBarByColumn(row, startDateColumn);
    }

    /**
     * Remove a range bar of the provided row and start column.
     *
     * @param {Number} row Row index.
     * @param {Number} startDateColumn Column index.
     */

  }, {
    key: 'removeRangeBarByColumn',
    value: function removeRangeBarByColumn(row, startDateColumn) {
      var _this7 = this;

      var rangeBar = this.rangeBars[row][startDateColumn];

      if (!rangeBar) {
        return;
      }

      this.unrenderRangeBar(row, startDateColumn, startDateColumn + rangeBar.barLength - 1);
      this.rangeBars[row][startDateColumn] = null;

      (0, _object.objectEach)(this.rangeList, function (prop, i) {
        i = parseInt(i, 10);

        if (JSON.stringify(prop) === JSON.stringify([row, startDateColumn])) {
          _this7.rangeList[i] = null;
        }
      });
    }

    /**
     * Remove all range bars from the chart-enabled Handsontable instance.
     */

  }, {
    key: 'removeAllRangeBars',
    value: function removeAllRangeBars() {
      var _this8 = this;

      (0, _object.objectEach)(this.rangeBars, function (row, i) {
        (0, _object.objectEach)(row, function (bar, j) {
          _this8.removeRangeBarByColumn(i, j);
        });
      });
    }

    /**
     * Remove a range bar from the table.
     *
     * @param {Number} row Row index.
     * @param {Number} startDateColumn Start column index.
     * @param {Number} endDateColumn End column index.
     */

  }, {
    key: 'unrenderRangeBar',
    value: function unrenderRangeBar(row, startDateColumn, endDateColumn) {
      for (var i = startDateColumn; i <= endDateColumn; i++) {
        var cellMeta = this.hot.getCellMeta(row, i);

        this.hot.setCellMeta(row, i, 'className', cellMeta.originalClassName);
        this.hot.setCellMeta(row, i, 'originalClassName', void 0);

        this.cacheRangeBarMeta(row, i, 'className', cellMeta.originalClassName);
        this.cacheRangeBarMeta(row, i, 'originalClassName', void 0);
      }

      this.hot.render();
    }

    /**
     * A default renderer of the range bars.
     *
     * @param {Object} instance HOT instance.
     * @param {HTMLElement} TD TD element.
     * @param {Number} row Row index.
     * @param {Number} col Column index.
     * @param {String|Number} prop Object data property.
     * @param {String|Number} value Value to pass to the cell.
     * @param {Object} cellProperties Current cell properties.
     */

  }, {
    key: 'uniformBackgroundRenderer',
    value: function uniformBackgroundRenderer(instance, TD, row, col, prop, value, cellProperties) {
      var rangeBarInfo = this.getRangeBarData(row, col);
      var rangeBarCoords = this.getRangeBarCoordinates(row);

      if (cellProperties.className) {
        TD.className = cellProperties.className;
      }

      var titleValue = '';

      (0, _object.objectEach)(cellProperties.additionalData, function (prop, i) {
        titleValue += i + ': ' + prop + '\n';
      });

      titleValue = titleValue.replace(/\n$/, '');

      TD.title = titleValue;

      if (rangeBarInfo && rangeBarInfo.colors) {
        if (col === rangeBarCoords[1] && rangeBarInfo.partialStart || col === rangeBarCoords[1] + rangeBarInfo.barLength - 1 && rangeBarInfo.partialEnd) {
          TD.style.background = rangeBarInfo.colors[1];
        } else {
          TD.style.background = rangeBarInfo.colors[0];
        }
      } else {
        TD.style.background = '';
      }
    }

    /**
     * Set range bar colors.
     *
     * @param {Object} rows Object containing row color data, see example.
     * @example
     * ```js
     *  hot.getPlugin('ganttChart').setRangeBarColors({
     *    0: ['blue', 'lightblue'] // paints the bar in the first row blue, with partial sections colored light blue
      *   2: ['#2A74D0', '#588DD0'] // paints the bar in the thrid row with #2A74D0, with partial sections colored with #588DD0
     *  });
     * ```
     */

  }, {
    key: 'setRangeBarColors',
    value: function setRangeBarColors(rows) {
      var _this9 = this;

      this.colorData = rows;

      (0, _object.objectEach)(rows, function (colors, i) {
        var barCoords = _this9.getRangeBarCoordinates(i);

        if (barCoords) {
          _this9.updateRangeBarData(barCoords[0], barCoords[1], {
            colors: colors
          });
        }
      });

      this.hot.render();
    }

    /**
     * Update the chart with a new year.
     *
     * @param {Number} year New chart year.
     */

  }, {
    key: 'setYear',
    value: function setYear(year) {
      var newSettings = (0, _object.extend)(this.hot.getSettings().ganttChart, {
        startYear: year
      });

      this.hot.updateSettings({
        ganttChart: newSettings
      });
    }

    /**
     * AfterInit hook callback.
     *
     * @private
     */

  }, {
    key: 'onAfterInit',
    value: function onAfterInit() {
      this.nestedHeadersPlugin = this.hot.getPlugin('nestedHeaders');

      this.applyDataSource();
    }

    /**
     * Prevent update settings loop when assigning the additional internal settings.
     *
     * @private
     */

  }, {
    key: 'onUpdateSettings',
    value: function onUpdateSettings() {
      if (this.internalUpdateSettings) {
        this.applyRangeBarMetaCache();

        return;
      }

      _get(GanttChart.prototype.__proto__ || Object.getPrototypeOf(GanttChart.prototype), 'onUpdateSettings', this).call(this);
    }

    /**
     * Destroy the plugin
     *
     * @private
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.hotSource) {
        this.dataFeed.removeSourceHotHooks(this.hotSource);
      }

      _get(GanttChart.prototype.__proto__ || Object.getPrototypeOf(GanttChart.prototype), 'destroy', this).call(this);
    }
  }]);

  return GanttChart;
}(_base2.default);

(0, _plugins.registerPlugin)('ganttChart', GanttChart);

exports.default = GanttChart;