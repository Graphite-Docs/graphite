var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import BasePlugin from 'handsontable/plugins/_base';
import { arrayEach } from 'handsontable/helpers/array';
import { rangeEach } from 'handsontable/helpers/number';
import { registerPlugin } from 'handsontable/plugins';
import RowsMapper from './rowsMapper';

/**
 * @plugin TrimRows
 * @pro
 *
 * @description
 * Plugin allowing hiding of certain rows.
 *
 * @example
 *
 * ```js
 * ...
 * var hot = new Handsontable(document.getElementById('example'), {
 *   date: getData(),
 *   trimRows: [1, 2, 5]
 * });
 * // Access to trimRows plugin instance:
 * var trimRowsPlugin = hot.getPlugin('trimRows');
 *
 * // Hide row programmatically:
 * trimRowsPlugin.trimRow(1);
 * // Show rows
 * trimRowsPlugin.trimRow(1, 2, 9);
 * // or
 * trimRowsPlugin.trimRows([1, 2, 9]);
 * hot.render();
 * ...
 * // Show row programmatically:
 * trimRowsPlugin.untrimRow(1);
 * // Hide rows
 * trimRowsPlugin.untrimRow(1, 2, 9);
 * // or
 * trimRowsPlugin.untrimRows([1, 2, 9]);
 * hot.render();
 * ...
 * ```
 */

var TrimRows = function (_BasePlugin) {
  _inherits(TrimRows, _BasePlugin);

  function TrimRows(hotInstance) {
    _classCallCheck(this, TrimRows);

    /**
     * List of trimmed row indexes.
     *
     * @type {Array}
     */
    var _this = _possibleConstructorReturn(this, (TrimRows.__proto__ || Object.getPrototypeOf(TrimRows)).call(this, hotInstance));

    _this.trimmedRows = [];
    /**
     * List of last removed row indexes.
     *
     * @type {Array}
     */
    _this.removedRows = [];
    /**
     * Object containing visual row indexes mapped to data source indexes.
     *
     * @type {RowsMapper}
     */
    _this.rowsMapper = new RowsMapper(_this);
    return _this;
  }

  /**
   * Check if plugin is enabled.
   *
   * @returns {Boolean}
   */


  _createClass(TrimRows, [{
    key: 'isEnabled',
    value: function isEnabled() {
      return !!this.hot.getSettings().trimRows;
    }

    /**
     * Enable the plugin.
     */

  }, {
    key: 'enablePlugin',
    value: function enablePlugin() {
      var _this2 = this;

      if (this.enabled) {
        return;
      }
      var settings = this.hot.getSettings().trimRows;

      if (Array.isArray(settings)) {
        this.trimmedRows = settings;
      }
      this.rowsMapper.createMap(this.hot.countSourceRows());

      this.addHook('modifyRow', function (row, source) {
        return _this2.onModifyRow(row, source);
      });
      this.addHook('unmodifyRow', function (row, source) {
        return _this2.onUnmodifyRow(row, source);
      });
      this.addHook('beforeCreateRow', function (index, amount, source) {
        return _this2.onBeforeCreateRow(index, amount, source);
      });
      this.addHook('afterCreateRow', function (index, amount) {
        return _this2.onAfterCreateRow(index, amount);
      });
      this.addHook('beforeRemoveRow', function (index, amount) {
        return _this2.onBeforeRemoveRow(index, amount);
      });
      this.addHook('afterRemoveRow', function (index, amount) {
        return _this2.onAfterRemoveRow(index, amount);
      });
      this.addHook('afterLoadData', function (firstRun) {
        return _this2.onAfterLoadData(firstRun);
      });

      _get(TrimRows.prototype.__proto__ || Object.getPrototypeOf(TrimRows.prototype), 'enablePlugin', this).call(this);
    }

    /**
     * Updates the plugin to use the latest options you have specified.
     */

  }, {
    key: 'updatePlugin',
    value: function updatePlugin() {
      var settings = this.hot.getSettings().trimRows;

      if (Array.isArray(settings)) {
        this.disablePlugin();
        this.enablePlugin();
      }

      _get(TrimRows.prototype.__proto__ || Object.getPrototypeOf(TrimRows.prototype), 'updatePlugin', this).call(this);
    }

    /**
     * Disable the plugin.
     */

  }, {
    key: 'disablePlugin',
    value: function disablePlugin() {
      this.trimmedRows = [];
      this.removedRows.length = 0;
      this.rowsMapper.clearMap();
      _get(TrimRows.prototype.__proto__ || Object.getPrototypeOf(TrimRows.prototype), 'disablePlugin', this).call(this);
    }

    /**
     * Trim the rows provided in the array.
     *
     * @param {Array} rows Array of physical row indexes.
     */

  }, {
    key: 'trimRows',
    value: function trimRows(rows) {
      var _this3 = this;

      arrayEach(rows, function (row) {
        row = parseInt(row, 10);

        if (!_this3.isTrimmed(row)) {
          _this3.trimmedRows.push(row);
        }
      });

      this.hot.runHooks('skipLengthCache', 100);
      this.rowsMapper.createMap(this.hot.countSourceRows());
      this.hot.runHooks('afterTrimRow', rows);
    }

    /**
     * Trim the row provided as physical row index (counting from 0).
     *
     * @param {Number} row Physical row index.
     */

  }, {
    key: 'trimRow',
    value: function trimRow() {
      for (var _len = arguments.length, row = Array(_len), _key = 0; _key < _len; _key++) {
        row[_key] = arguments[_key];
      }

      this.trimRows(row);
    }

    /**
     * Untrim the rows provided in the array.
     *
     * @param {Array} rows Array of physical row indexes.
     */

  }, {
    key: 'untrimRows',
    value: function untrimRows(rows) {
      var _this4 = this;

      arrayEach(rows, function (row) {
        row = parseInt(row, 10);

        if (_this4.isTrimmed(row)) {
          _this4.trimmedRows.splice(_this4.trimmedRows.indexOf(row), 1);
        }
      });

      this.hot.runHooks('skipLengthCache', 100);
      this.rowsMapper.createMap(this.hot.countSourceRows());
      this.hot.runHooks('afterUntrimRow', rows);
    }

    /**
     * Untrim the row provided as row index (counting from 0).
     *
     * @param {Number} row Physical row index.
     */

  }, {
    key: 'untrimRow',
    value: function untrimRow() {
      for (var _len2 = arguments.length, row = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        row[_key2] = arguments[_key2];
      }

      this.untrimRows(row);
    }

    /**
     * Check if given physical row is hidden.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'isTrimmed',
    value: function isTrimmed(row) {
      return this.trimmedRows.indexOf(row) > -1;
    }

    /**
     * Untrim all trimmed rows.
     */

  }, {
    key: 'untrimAll',
    value: function untrimAll() {
      this.untrimRows([].concat(this.trimmedRows));
    }

    /**
     * On modify row listener.
     *
     * @private
     * @param {Number} row Visual row index.
     * @param {String} source Source name.
     * @returns {Number|null}
     */

  }, {
    key: 'onModifyRow',
    value: function onModifyRow(row, source) {
      if (source !== this.pluginName) {
        row = this.rowsMapper.getValueByIndex(row);
      }

      return row;
    }

    /**
     * On unmodifyRow listener.
     *
     * @private
     * @param {Number} row Physical row index.
     * @param {String} source Source name.
     * @returns {Number|null}
     */

  }, {
    key: 'onUnmodifyRow',
    value: function onUnmodifyRow(row, source) {
      if (source !== this.pluginName) {
        row = this.rowsMapper.getIndexByValue(row);
      }

      return row;
    }

    /**
     * `beforeCreateRow` hook callback.
     *
     * @private
     * @param {Number} index Index of the newly created row.
     * @param {Number} amount Amount of created rows.
     * @param {String} source Source of the change.
     */

  }, {
    key: 'onBeforeCreateRow',
    value: function onBeforeCreateRow(index, amount, source) {
      return !(this.isEnabled() && this.trimmedRows.length > 0 && source === 'auto');
    }

    /**
     * On after create row listener.
     *
     * @private
     * @param {Number} index Visual row index.
     * @param {Number} amount Defines how many rows removed.
     */

  }, {
    key: 'onAfterCreateRow',
    value: function onAfterCreateRow(index, amount) {
      this.rowsMapper.shiftItems(index, amount);
    }

    /**
     * On before remove row listener.
     *
     * @private
     * @param {Number} index Visual row index.
     * @param {Number} amount Defines how many rows removed.
     */

  }, {
    key: 'onBeforeRemoveRow',
    value: function onBeforeRemoveRow(index, amount) {
      var _this5 = this;

      this.removedRows.length = 0;

      if (index !== false) {
        // Collect physical row index.
        rangeEach(index, index + amount - 1, function (removedIndex) {
          _this5.removedRows.push(_this5.hot.runHooks('modifyRow', removedIndex, _this5.pluginName));
        });
      }
    }

    /**
     * On after remove row listener.
     *
     * @private
     * @param {Number} index Visual row index.
     * @param {Number} amount Defines how many rows removed.
     */

  }, {
    key: 'onAfterRemoveRow',
    value: function onAfterRemoveRow(index, amount) {
      this.rowsMapper.unshiftItems(this.removedRows);
    }

    /**
     * On after load data listener.
     *
     * @private
     * @param {Boolean} firstRun Indicates if hook was fired while Handsontable initialization.
     */

  }, {
    key: 'onAfterLoadData',
    value: function onAfterLoadData(firstRun) {
      if (!firstRun) {
        this.rowsMapper.createMap(this.hot.countSourceRows());
      }
    }

    /**
     * Destroy plugin.
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.rowsMapper.destroy();
      _get(TrimRows.prototype.__proto__ || Object.getPrototypeOf(TrimRows.prototype), 'destroy', this).call(this);
    }
  }]);

  return TrimRows;
}(BasePlugin);

registerPlugin('trimRows', TrimRows);

export default TrimRows;