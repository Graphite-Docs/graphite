var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { objectEach, deepClone } from 'handsontable/helpers/object';
import { arrayEach } from 'handsontable/helpers/array';
import DateCalculator from './dateCalculator';

/**
 * This class handles the data-related calculations for the GanttChart plugin.
 *
 * @plugin GanttChart
 */

var GanttChartDataFeed = function () {
  function GanttChartDataFeed(chartInstance, data, startDateColumn, endDateColumn, additionalData, asyncUpdates) {
    _classCallCheck(this, GanttChartDataFeed);

    this.data = data;
    this.chartInstance = chartInstance;
    this.chartPlugin = this.chartInstance.getPlugin('ganttChart');
    this.hotSource = null;
    this.sourceHooks = {};
    this.ongoingAsync = false;

    this.applyData(data, startDateColumn, endDateColumn, additionalData, asyncUpdates || false);
  }

  /**
   * Parse data accordingly to it's type (HOT instance / data object).
   *
   * @param {Object} data The source Handsontable instance or a data object.
   * @param {Number} startDateColumn Index of the column containing the start dates.
   * @param {Number} endDateColumn Index of the column containing the end dates.
   * @param {Object} additionalData Object containing column and label information about additional data passed to the Gantt Plugin.
   * @param {Boolean} asyncUpdates If set to true, the source instance updates will be applied asynchronously.
   */


  _createClass(GanttChartDataFeed, [{
    key: 'applyData',
    value: function applyData(data, startDateColumn, endDateColumn, additionalData, asyncUpdates) {
      if (Object.prototype.toString.call(data) === '[object Array]') {
        this.loadData(data);

        // if data is a Handsontable instance (probably not the best way to recognize it)
      } else if (data.guid) {
        this.bindWithHotInstance(data, startDateColumn, endDateColumn, additionalData, asyncUpdates);
      }
    }

    /**
     * Make another Handsontable instance be a live feed for the gantt chart.
     *
     * @param {Object} instance The source Handsontable instance.
     * @param {Number} startDateColumn Index of the column containing the start dates.
     * @param {Number} endDateColumn Index of the column containing the end dates.
     * @param {Object} additionalData Object containing column and label information about additional data passed to the
     * Gantt Plugin. See the example for more details.
     * @param {Boolean} asyncUpdates If set to true, the source instance updates will be applied asynchronously.
     *
     * @example
     * ```js
     * hot.getPlugin('ganttChart').bindWithHotInstance(sourceInstance, 4, 5, {
     *  vendor: 0, // data labeled 'vendor' is stored in the first sourceInstance column.
     *  format: 1, // data labeled 'format' is stored in the second sourceInstance column.
     *  market: 2 // data labeled 'market' is stored in the third sourceInstance column.
     * });
     * ```
     */

  }, {
    key: 'bindWithHotInstance',
    value: function bindWithHotInstance(instance, startDateColumn, endDateColumn, additionalData, asyncUpdates) {
      this.hotSource = {
        instance: instance,
        startColumn: startDateColumn,
        endColumn: endDateColumn,
        additionalData: additionalData,
        asyncUpdates: asyncUpdates
      };

      this.addSourceHotHooks();

      this.asyncCall(this.updateFromSource);
    }

    /**
     * Run the provided function asynchronously.
     *
     * @param {Function} func
     */

  }, {
    key: 'asyncCall',
    value: function asyncCall(func) {
      var _this = this;

      if (!this.hotSource.asyncUpdates) {
        func.call(this);

        return;
      }

      this.asyncStart();

      setTimeout(function () {
        func.call(_this);

        _this.asyncEnd();
      }, 0);
    }
  }, {
    key: 'asyncStart',
    value: function asyncStart() {
      this.ongoingAsync = true;
    }
  }, {
    key: 'asyncEnd',
    value: function asyncEnd() {
      this.ongoingAsync = false;
    }

    /**
     * Add hooks to the source Handsontable instance.
     *
     * @private
     */

  }, {
    key: 'addSourceHotHooks',
    value: function addSourceHotHooks() {
      var _this2 = this;

      this.sourceHooks = {
        afterLoadData: function afterLoadData(firstRun) {
          return _this2.onAfterSourceLoadData(firstRun);
        },
        afterChange: function afterChange(changes, source) {
          return _this2.onAfterSourceChange(changes, source);
        },
        afterColumnSort: function afterColumnSort(column, order) {
          return _this2.onAfterColumnSort(column, order);
        }
      };

      this.hotSource.instance.addHook('afterLoadData', this.sourceHooks.afterLoadData);
      this.hotSource.instance.addHook('afterChange', this.sourceHooks.afterChange);
      this.hotSource.instance.addHook('afterColumnSort', this.sourceHooks.afterColumnSort);
    }

    /**
     * Remove hooks from the source Handsontable instance.
     *
     * @private
     * @param {Object} hotSource The source Handsontable instance object.
     */

  }, {
    key: 'removeSourceHotHooks',
    value: function removeSourceHotHooks(hotSource) {
      if (this.sourceHooks.afterLoadData) {
        hotSource.instance.removeHook('afterLoadData', this.sourceHooks.afterLoadData);
      }

      if (this.sourceHooks.afterChange) {
        hotSource.instance.removeHook('afterChange', this.sourceHooks.afterChange);
      }

      if (this.sourceHooks.afterColumnSort) {
        hotSource.instance.removeHook('afterColumnSort', this.sourceHooks.afterColumnSort);
      }
    }

    /**
     * Get data from the source Handsontable instance.
     *
     * @param {Number} [row] Source Handsontable instance row.
     * @returns {Array}
     */

  }, {
    key: 'getDataFromSource',
    value: function getDataFromSource(row) {
      var additionalObjectData = {};
      var hotSource = this.hotSource;
      var sourceHotRows = void 0;
      var rangeBarData = [];

      if (row === void 0) {
        sourceHotRows = hotSource.instance.getData(0, 0, hotSource.instance.countRows() - 1, hotSource.instance.countCols() - 1);
      } else {
        sourceHotRows = [];
        sourceHotRows[row] = hotSource.instance.getDataAtRow(row);
      }

      var _loop = function _loop(i, dataLength) {
        additionalObjectData = {};
        var currentRow = sourceHotRows[i];

        if (currentRow[hotSource.startColumn] === null || currentRow[hotSource.startColumn] === '') {
          /* eslint-disable no-continue */
          return 'continue';
        }

        /* eslint-disable no-loop-func */
        objectEach(hotSource.additionalData, function (prop, j) {
          additionalObjectData[j] = currentRow[prop];
        });

        rangeBarData.push([i, currentRow[hotSource.startColumn], currentRow[hotSource.endColumn], additionalObjectData, i]);
      };

      for (var i = row || 0, dataLength = sourceHotRows.length; i < (row ? row + 1 : dataLength); i++) {
        var _ret = _loop(i, dataLength);

        if (_ret === 'continue') continue;
      }

      return rangeBarData;
    }

    /**
     * Update the Gantt Chart-enabled Handsontable instance with the data from the source Handsontable instance.
     *
     * @param {Number} [row] Index of the row which needs updating.
     */

  }, {
    key: 'updateFromSource',
    value: function updateFromSource(row) {
      var _this3 = this;

      var dataFromSource = this.getDataFromSource(row);

      if (!row && isNaN(row)) {
        this.chartPlugin.clearRangeBars();
        this.chartPlugin.clearRangeList();
      }

      arrayEach(dataFromSource, function (bar) {
        bar = _this3.trimRangeIfNeeded(bar);
        _this3.chartPlugin.addRangeBar.apply(_this3.chartPlugin, bar);
      });
    }

    /**
     * Load chart data to the Handsontable instance.
     *
     * @param {Array} data Array of objects containing the range data.
     *
     * @example
     * ```js
     * [
     *  {
     *    additionalData: {vendor: 'Vendor One', format: 'Posters', market: 'New York, NY'},
     *    startDate: '1/5/2015',
     *    endDate: '1/20/2015'
     *  },
     *  {
     *    additionalData: {vendor: 'Vendor Two', format: 'Malls', market: 'Los Angeles, CA'},
     *    startDate: '1/11/2015',
     *    endDate: '1/29/2015'
     *  }
     * ]
     * ```
     */

  }, {
    key: 'loadData',
    value: function loadData(data) {
      var _this4 = this;

      arrayEach(data, function (bar, i) {
        bar = _this4.trimRangeIfNeeded(bar);
        _this4.chartPlugin.addRangeBar(i, bar.startDate, bar.endDate, bar.additionalData);
      });
    }

    /**
     * Trim the dates in the provided range bar, if they exceed the currently processed year.
     *
     * @param {Array|Object} bar Range bar data.
     * @returns {Array}
     */

  }, {
    key: 'trimRangeIfNeeded',
    value: function trimRangeIfNeeded(bar) {
      var dateProps = null;
      if (bar[1]) {
        dateProps = {
          startDate: 1,
          endDate: 2
        };
      } else {
        dateProps = {
          startDate: 'startDate',
          endDate: 'endDate'
        };
      }

      var startDate = new Date(bar[dateProps.startDate]);
      var endDate = new Date(bar[dateProps.endDate]);

      if (typeof startDate === 'string' || typeof endDate === 'string') {
        return false;
      }

      var startYear = startDate.getFullYear();
      var endYear = endDate.getFullYear();

      if (startYear < this.chartPlugin.currentYear && endYear >= this.chartPlugin.currentYear) {
        bar[dateProps.startDate] = '01/01/' + this.chartPlugin.currentYear;
      }

      if (endYear > this.chartPlugin.currentYear && startYear <= this.chartPlugin.currentYear) {
        bar[dateProps.endDate] = '12/31/' + this.chartPlugin.currentYear;
      }

      return bar;
    }

    /**
     * afterChange hook callback for the source Handsontable instance.
     *
     * @private
     * @param {Array} changes List of changes.
     * @param {String} source Change source.
     */

  }, {
    key: 'onAfterSourceChange',
    value: function onAfterSourceChange(changes, source) {
      var _this5 = this;

      this.asyncCall(function () {
        if (!changes) {
          return;
        }

        var changesByRows = {};

        for (var i = 0, changesLength = changes.length; i < changesLength; i++) {
          var currentChange = changes[i];
          var row = parseInt(currentChange[0], 10);
          var col = parseInt(currentChange[1], 10);

          if (!changesByRows[row]) {
            changesByRows[row] = {};
          }

          changesByRows[row][col] = [currentChange[2], currentChange[3]];
        }

        objectEach(changesByRows, function (prop, i) {
          i = parseInt(i, 10);

          if (_this5.chartPlugin.getRangeBarCoordinates(i)) {
            _this5.chartPlugin.removeRangeBarByColumn(i, _this5.chartPlugin.rangeList[i][1]);
          }

          _this5.updateFromSource(i);
        });
      });
    }

    /**
     * afterLoadData hook callback for the source Handsontable instance.
     *
     * @private
     * @param firstRun
     */

  }, {
    key: 'onAfterSourceLoadData',
    value: function onAfterSourceLoadData(firstRun) {
      var _this6 = this;

      this.asyncCall(function (firstRun) {
        _this6.chartPlugin.removeAllRangeBars();
        _this6.updateFromSource();
      });
    }

    /**
     * afterColumnSort hook callback for the source Handsontable instance.
     *
     * @private
     * @param {Number} column Sorted column.
     * @param order
     */

  }, {
    key: 'onAfterColumnSort',
    value: function onAfterColumnSort(column, order) {
      var _this7 = this;

      this.asyncCall(function () {
        _this7.chartPlugin.removeAllRangeBars();
        _this7.updateFromSource();
      });
    }
  }]);

  return GanttChartDataFeed;
}();

export default GanttChartDataFeed;