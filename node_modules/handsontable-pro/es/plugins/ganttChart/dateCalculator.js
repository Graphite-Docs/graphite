var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { arrayEach } from 'handsontable/helpers/array';
import { objectEach } from 'handsontable/helpers/object';
import { getMixedMonthObject, getMixedMonthName } from './utils';

/**
 * This class handles the date-related calculations for the GanttChart plugin.
 *
 * @plugin GanttChart
 */

var DateCalculator = function () {
  function DateCalculator(year, allowSplitWeeks) {
    _classCallCheck(this, DateCalculator);

    /**
     * Year to base calculations on.
     *
     * @type {Number}
     */
    this.year = year;
    /**
     * First day of the week.
     *
     * @type {String}
     */
    this.firstWeekDay = 'monday';
    /**
     * The current `allowSplitWeeks` option state.
     */
    this.allowSplitWeeks = allowSplitWeeks === void 0 ? true : allowSplitWeeks;
    /**
     * Number of week sections (full weeks + incomplete week blocks in months).
     *
     * @type {Number}
     */
    this.weekSectionCount = 0;
    /**
     * List of months and their week/day related information.
     *
     * @type {Array}
     */
    this.monthList = this.calculateMonthData();
    /**
     * Object containing references to the year days and their corresponding columns.
     *
     * @type {Object}
     */
    this.daysInColumns = {};

    this.calculateWeekStructure();
  }

  /**
   * Set the year as a base for calculations.
   *
   * @param {Number} year
   */


  _createClass(DateCalculator, [{
    key: 'setYear',
    value: function setYear(year) {
      this.year = year;

      this.monthList = this.calculateMonthData();
      this.calculateWeekStructure();
    }

    /**
     * Set the first week day.
     *
     * @param {String} day Day of the week. Available options: 'monday' or 'sunday'.
     */

  }, {
    key: 'setFirstWeekDay',
    value: function setFirstWeekDay(day) {
      var lowercaseDay = day.toLowerCase();

      if (lowercaseDay !== 'monday' && lowercaseDay !== 'sunday') {
        console.warn('First day of the week must be set to either Monday or Sunday');
      }

      this.firstWeekDay = lowercaseDay;

      this.calculateWeekStructure();
    }

    /**
     * Count week sections (full weeks + incomplete weeks in the months).
     *
     * @returns {Number} Week section count.
     */

  }, {
    key: 'countWeekSections',
    value: function countWeekSections() {
      return this.weekSectionCount;
    }

    /**
     * Get the first week day.
     *
     * @returns {String}
     */

  }, {
    key: 'getFirstWeekDay',
    value: function getFirstWeekDay() {
      return this.firstWeekDay;
    }

    /**
     * Get the currently applied year.
     *
     * @returns {Number}
     */

  }, {
    key: 'getYear',
    value: function getYear() {
      return this.year;
    }

    /**
     * Get month list along with the month information.
     *
     * @returns {Array}
     */

  }, {
    key: 'getMonthList',
    value: function getMonthList() {
      return this.monthList;
    }

    /**
     * Parse the provided date and check if it's valid.
     *
     * @param {String|Date} date Date string or object.
     * @returns {Date|null} Parsed Date object or null, if not a valid date string.
     */

  }, {
    key: 'parseDate',
    value: function parseDate(date) {
      if (!(date instanceof Date)) {
        date = new Date(date);

        if (date.toString() === 'Invalid Date') {
          return null;
        }
      }

      return date;
    }

    /**
     * Convert a date to a column number.
     *
     * @param {String|Date} date
     * @returns {Number|Boolean}
     */

  }, {
    key: 'dateToColumn',
    value: function dateToColumn(date) {
      date = this.parseDate(date);
      if (!date || date.getFullYear() !== this.year) {
        return false;
      }

      var month = date.getMonth();
      var day = date.getDate() - 1;

      return this.getWeekColumn(day, month);
    }

    /**
     * Get the column index for the provided day and month indexes.
     *
     * @private
     * @param {Number} dayIndex The index of the day.
     * @param {Number} monthIndex The index of the month.
     * @returns {Number} Returns the column index.
     */

  }, {
    key: 'getWeekColumn',
    value: function getWeekColumn(dayIndex, monthIndex) {
      var resultColumn = null;
      var monthCacheArray = this.getMonthCacheArray(monthIndex);

      arrayEach(monthCacheArray, function (monthCache) {
        objectEach(monthCache, function (column, index) {
          if (column.indexOf(dayIndex + 1) > -1) {
            resultColumn = parseInt(index, 10);

            return false;
          }
        });

        if (resultColumn) {
          return false;
        }
      });

      return resultColumn;
    }

    /**
     * Get the cached day array for the provided month.
     *
     * @private
     * @param {Number} monthIndex Index of the Month
     * @returns {Array}
     */

  }, {
    key: 'getMonthCacheArray',
    value: function getMonthCacheArray(monthIndex) {
      var _this = this;

      var monthList = this.getMonthList();
      var resultArray = [];

      if (this.allowSplitWeeks) {
        resultArray.push(this.daysInColumns[monthIndex]);
      } else {
        var fullMonthCount = -1;
        objectEach(this.daysInColumns, function (month, i) {
          var monthObject = monthList[i];

          if (Object.keys(month).length > 1) {
            fullMonthCount++;
          }

          if (fullMonthCount === monthIndex) {
            if (monthObject.daysBeforeFullWeeks > 0) {
              resultArray.push(_this.daysInColumns[parseInt(i, 10) - 1]);
            }

            resultArray.push(month);

            if (monthObject.daysAfterFullWeeks > 0) {
              resultArray.push(_this.daysInColumns[parseInt(i, 10) + 1]);
            }

            return false;
          }
        });
      }

      return resultArray;
    }

    /**
     * Convert a column index to a certain date.
     *
     * @param {Number} column
     * @returns {Date|Array}
     */

  }, {
    key: 'columnToDate',
    value: function columnToDate(column) {
      var month = null;

      objectEach(this.daysInColumns, function (monthCache, index) {
        if (monthCache[column]) {
          month = index;

          return false;
        }
      });

      if (this.daysInColumns[month][column].length === 1) {
        return new Date(this.year, month, this.daysInColumns[month][column][0]);
      }

      // TODO: this should look like {start: startDate, end: endDate}
      return this.daysInColumns[month][column];
    }

    /**
     * Check if the provided date is a starting or an ending day of a week.
     *
     * @private
     * @param {Date|String} date
     * @returns {Array|Boolean} Returns null, if an invalid date was provided or an array of results ( [1,0] => is on the beginning of the week, [0,1] => is on the end of the week).
     */

  }, {
    key: 'isOnTheEdgeOfWeek',
    value: function isOnTheEdgeOfWeek(date) {
      var _this2 = this;

      date = this.parseDate(date);

      if (!date) {
        return null;
      }

      var month = date.getMonth();
      var day = date.getDate() - 1;
      var monthCacheArray = this.getMonthCacheArray(month);
      var isOnTheEdgeOfWeek = false;

      arrayEach(monthCacheArray, function (monthCache) {
        objectEach(monthCache, function (column) {

          if (!_this2.allowSplitWeeks && column.length !== 7) {
            if (day === 0 || day === new Date(date.getYear(), date.getMonth() + 1, 0).getDate() - 1) {
              return true;
            }
          }

          var indexOfDay = column.indexOf(day + 1);

          if (indexOfDay === 0) {
            isOnTheEdgeOfWeek = [1, 0];
            return false;
          } else if (indexOfDay === column.length - 1) {
            isOnTheEdgeOfWeek = [0, 1];
            return false;
          }
        });

        // break the iteration
        if (isOnTheEdgeOfWeek) {
          return false;
        }
      });

      return isOnTheEdgeOfWeek;
    }

    /**
     * Add days to the column/day cache.
     *
     * @private
     * @param {Number} monthNumber Index of the month.
     * @param {Number} columnNumber Index of the column.
     * @param {Number} start First day in the column.
     * @param {Number} end Last day in the column.
     */

  }, {
    key: 'addDaysToCache',
    value: function addDaysToCache(monthNumber, columnNumber, start, end) {
      if (!this.daysInColumns[monthNumber]) {
        this.daysInColumns[monthNumber] = {};
      }
      if (!this.daysInColumns[monthNumber][columnNumber]) {
        this.daysInColumns[monthNumber][columnNumber] = [];
      }

      if (start <= end) {
        for (var dayIndex = start; dayIndex <= end; dayIndex++) {
          this.daysInColumns[monthNumber][columnNumber].push(dayIndex);
        }
      } else {
        var previousMonthDaysCount = monthNumber - 1 >= 0 ? this.countMonthDays(monthNumber) : 31;

        for (var _dayIndex = start; _dayIndex <= previousMonthDaysCount; _dayIndex++) {
          this.daysInColumns[monthNumber][columnNumber].push(_dayIndex);
        }

        for (var _dayIndex2 = 1; _dayIndex2 <= end; _dayIndex2++) {
          this.daysInColumns[monthNumber][columnNumber].push(_dayIndex2);
        }
      }
    }

    /**
     * Check if the provided dates can be used in a range bar.
     *
     * @param {Date|String} startDate Range start date.
     * @param {Date|String} endDate Range end date.
     * @returns {Boolean}
     */

  }, {
    key: 'isValidRangeBarData',
    value: function isValidRangeBarData(startDate, endDate) {
      var startDateParsed = this.parseDate(startDate);
      var endDateParsed = this.parseDate(endDate);

      return startDateParsed && endDateParsed && startDateParsed.getTime() <= endDateParsed.getTime();
    }

    /**
     * Calculate the month/day related information.
     *
     * @returns {Array}
     */

  }, {
    key: 'calculateMonthData',
    value: function calculateMonthData() {
      return [{ name: 'January', days: 31 }, { name: 'February', days: new Date(this.year, 2, 0).getDate() }, { name: 'March', days: 31 }, { name: 'April', days: 30 }, { name: 'May', days: 31 }, { name: 'June', days: 30 }, { name: 'July', days: 31 }, { name: 'August', days: 31 }, { name: 'September', days: 30 }, { name: 'October', days: 31 }, { name: 'November', days: 30 }, { name: 'December', days: 31 }].slice(0);
    }

    /**
     * Count the number of months.
     *
     * @returns {Number}
     */

  }, {
    key: 'countMonths',
    value: function countMonths() {
      return this.monthList.length;
    }

    /**
     * Count days in a month.
     *
     * @param {Number} month Month index, where January = 1, February = 2, etc.
     * @returns {Number}
     */

  }, {
    key: 'countMonthDays',
    value: function countMonthDays(month) {
      return this.monthList[month - 1].days;
    }

    /**
     * Count full weeks in a month.
     *
     * @param {Number} month Month index, where January = 1, February = 2, etc.
     * @returns {Number}
     */

  }, {
    key: 'countMonthFullWeeks',
    value: function countMonthFullWeeks(month) {
      return this.monthList[month - 1].fullWeeks;
    }

    /**
     * Calculate week structure within defined months.
     *
     * @private
     */

  }, {
    key: 'calculateWeekStructure',
    value: function calculateWeekStructure() {
      var _this3 = this;

      this.monthList = this.calculateMonthData();

      var firstWeekDay = this.getFirstWeekDay();
      var monthList = this.getMonthList();
      var currentYear = this.getYear();
      var mixedMonthToAdd = [];
      var weekOffset = 0;
      var weekSectionCount = 0;

      if (firstWeekDay === 'monday') {
        weekOffset = 1;
      }

      arrayEach(monthList, function (currentMonth, monthIndex) {
        var firstMonthDay = new Date(currentYear, monthIndex, 1).getDay();
        var mixedMonthsAdded = 0;
        var mixedMonthName = null;

        currentMonth.daysBeforeFullWeeks = (7 - firstMonthDay + weekOffset) % 7;

        if (!_this3.allowSplitWeeks && currentMonth.daysBeforeFullWeeks) {
          mixedMonthName = getMixedMonthName(monthIndex, monthList);

          mixedMonthToAdd.push(getMixedMonthObject(mixedMonthName, monthIndex));

          mixedMonthsAdded++;
        }

        currentMonth.fullWeeks = Math.floor((currentMonth.days - currentMonth.daysBeforeFullWeeks) / 7);
        currentMonth.daysAfterFullWeeks = currentMonth.days - currentMonth.daysBeforeFullWeeks - 7 * currentMonth.fullWeeks;

        if (!_this3.allowSplitWeeks) {
          if (monthIndex === monthList.length - 1 && currentMonth.daysAfterFullWeeks) {
            mixedMonthName = getMixedMonthName(monthIndex, monthList);

            mixedMonthToAdd.push(getMixedMonthObject(mixedMonthName, null));

            mixedMonthsAdded++;
          }

          weekSectionCount += currentMonth.fullWeeks + mixedMonthsAdded;
        } else {
          weekSectionCount += currentMonth.fullWeeks + (currentMonth.daysBeforeFullWeeks ? 1 : 0) + (currentMonth.daysAfterFullWeeks ? 1 : 0);
        }
      });

      arrayEach(mixedMonthToAdd, function (monthObject, monthIndex) {
        var index = monthObject.index;

        delete monthObject.index;

        _this3.addMixedMonth(index === null ? index : monthIndex + index, monthObject);
      });

      this.weekSectionCount = weekSectionCount;
    }

    /**
     * Add a mixed (e.g. 'Jan/Feb') month to the month list.
     *
     * @private
     * @param {Number} index Index for the month.
     * @param {Object} monthObject The month object.
     */

  }, {
    key: 'addMixedMonth',
    value: function addMixedMonth(index, monthObject) {
      if (index === null) {
        this.monthList.push(monthObject);
      } else {
        this.monthList.splice(index, 0, monthObject);
      }
    }
  }]);

  return DateCalculator;
}();

export default DateCalculator;