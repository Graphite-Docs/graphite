var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import BasePlugin from 'handsontable/plugins/_base';
import { objectEach, extend, clone } from 'handsontable/helpers/object';
import { registerPlugin } from 'handsontable/plugins';
import DataProvider from './dataProvider';
import typeFactory, { EXPORT_TYPES } from './typeFactory';

/**
 * @plugin ExportFile
 * @pro
 *
 * @example
 *
 * ```js
 * ...
 * var hot = new Handsontable(document.getElementById('example'), {
 *   data: getData()
 * });
 * // Access to exportFile plugin instance:
 * var exportPlugin = hot.getPlugin('exportFile');
 *
 * // Export as a string:
 * exportPlugin.exportAsString('csv');
 *
 * // Export as a Blob object:
 * exportPlugin.exportAsBlob('csv');
 *
 * // Export to downloadable file (MyFile.csv):
 * exportPlugin.downloadFile('csv', {filename: 'MyFile'});
 *
 * // Export as a string (specified data range):
 * exportPlugin.exportAsString('csv', {
 *   exportHiddenRows: true,     // default false
 *   exportHiddenColumns: true,  // default false
 *   columnHeaders: true,        // default false
 *   rowHeaders: true,           // default false
 *   columnDelimiter: ';',       // default ','
 *   range: [1, 1, 6, 6]         // [startRow, endRow, startColumn, endColumn]
 * });
 * ...
 * ```
 */

var ExportFile = function (_BasePlugin) {
  _inherits(ExportFile, _BasePlugin);

  function ExportFile() {
    _classCallCheck(this, ExportFile);

    return _possibleConstructorReturn(this, (ExportFile.__proto__ || Object.getPrototypeOf(ExportFile)).apply(this, arguments));
  }

  _createClass(ExportFile, [{
    key: 'isEnabled',

    /**
     * Check if the plugin is enabled in the handsontable settings.
     *
     * @returns {Boolean}
     */
    value: function isEnabled() {
      return true;
    }

    /**
     * Export table data as a string.
     *
     * @param {String} format Export format type eq. `'csv'`.
     * @param {Object} options see ExportFile.DEFAULT_OPTIONS for available export options.
    */

  }, {
    key: 'exportAsString',
    value: function exportAsString(format) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this._createTypeFormatter(format, options).export();
    }

    /**
     * Export table data as a blob object.
     *
     * @param {String} format Export format type eq. `'csv'`.
     * @param {Object} options see ExportFile.DEFAULT_OPTIONS for available export options.
    */

  }, {
    key: 'exportAsBlob',
    value: function exportAsBlob(format) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this._createBlob(this._createTypeFormatter(format, options));
    }

    /**
     * Export table data as a downloadable file.
     *
     * @param {String} format Export format type eq. `'csv'`.
     * @param {Object} options see ExportFile.DEFAULT_OPTIONS for available export options.
     */

  }, {
    key: 'downloadFile',
    value: function downloadFile(format) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var formatter = this._createTypeFormatter(format, options);
      var blob = this._createBlob(formatter);
      var URL = window.URL || window.webkitURL;

      var a = document.createElement('a');
      var name = formatter.options.filename + '.' + formatter.options.fileExtension;

      if (a.download !== void 0) {
        var url = URL.createObjectURL(blob);

        a.style.display = 'none';
        a.setAttribute('href', url);
        a.setAttribute('download', name);
        document.body.appendChild(a);
        a.dispatchEvent(new MouseEvent('click'));
        document.body.removeChild(a);

        setTimeout(function () {
          URL.revokeObjectURL(url);
        }, 100);
      } else if (navigator.msSaveOrOpenBlob) {
        // IE10+
        navigator.msSaveOrOpenBlob(blob, name);
      }
    }

    /**
     * Create and return class formatter for specified export type.
     *
     * @private
     * @param {String} format Export format type eq. `'csv'`.
     * @param {Object} options see ExportFile.DEFAULT_OPTIONS for available export options.
     */

  }, {
    key: '_createTypeFormatter',
    value: function _createTypeFormatter(format) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!EXPORT_TYPES[format]) {
        throw new Error('Export format type "' + format + '" is not supported.');
      }

      return typeFactory(format, new DataProvider(this.hot), options);
    }

    /**
     * Create blob object based on provided type formatter class.
     *
     * @private
     * @param {BaseType} typeFormatter
     * @returns {Blob}
     */

  }, {
    key: '_createBlob',
    value: function _createBlob(typeFormatter) {
      var formatter = null;

      if (typeof Blob !== 'undefined') {
        formatter = new Blob([typeFormatter.export()], {
          type: typeFormatter.options.mimeType + ';charset=' + typeFormatter.options.encoding
        });
      }

      return formatter;
    }
  }]);

  return ExportFile;
}(BasePlugin);

registerPlugin('exportFile', ExportFile);

export default ExportFile;