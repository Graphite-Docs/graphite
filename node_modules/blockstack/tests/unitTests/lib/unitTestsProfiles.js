'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runProfilesUnitTests = runProfilesUnitTests;

var _tape = require('tape');

var _tape2 = _interopRequireDefault(_tape);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _bitcoinjsLib = require('bitcoinjs-lib');

var _fetchMock = require('fetch-mock');

var _fetchMock2 = _interopRequireDefault(_fetchMock);

var _proxyquire = require('proxyquire');

var _proxyquire2 = _interopRequireDefault(_proxyquire);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _lib = require('../../../lib');

var _sampleData = require('./sampleData');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function testTokening(filename, profile) {
  var privateKey = 'a5c61c6ca7b3e7e55edee68566aeab22e4da26baa285c7bd10e8d2218aa3b229';
  var publicKey = '027d28f9951ce46538951e3697c62588a87f1f1f295de4a14fdd4c780fc52cfe69';

  var tokenRecords = [];

  (0, _tape2.default)('profileToToken', function (t) {
    t.plan(3);

    var token = (0, _lib.signProfileToken)(profile, privateKey);
    t.ok(token, 'Token must have been created');

    var tokenRecord = (0, _lib.wrapProfileToken)(token);
    t.ok(tokenRecord, 'Token record must have been created');

    var decodedToken = (0, _lib.verifyProfileToken)(tokenRecord.token, publicKey);
    t.ok(decodedToken, 'Token record must have been verified');
  });

  (0, _tape2.default)('profileToTokens', function (t) {
    t.plan(2);

    tokenRecords = [(0, _lib.wrapProfileToken)((0, _lib.signProfileToken)(profile, privateKey))];
    t.ok(tokenRecords, 'Tokens should have been created');
    //console.log(JSON.stringify(tokenRecords, null, 2))
    //fs.writeFileSync('./docs/token-files/' + filename, JSON.stringify(tokenRecords, null, 2))

    var tokensVerified = true;
    tokenRecords.map(function (tokenRecord) {
      var decodedToken = (0, _lib.verifyProfileToken)(tokenRecord.token, publicKey);
    });
    t.equal(tokensVerified, true, 'All tokens should be valid');
  });

  (0, _tape2.default)('tokenToProfile', function (t) {
    t.plan(2);

    var recoveredProfile = (0, _lib.extractProfile)(tokenRecords[0].token, publicKey);
    //console.log(recoveredProfile)
    t.ok(recoveredProfile, 'Profile should have been reconstructed');
    t.equal(JSON.stringify(recoveredProfile), JSON.stringify(profile), 'Profile should equal the reference');
  });

  (0, _tape2.default)('makeProfileZoneFile', function (t) {
    t.plan(1);

    var origin = 'satoshi.id';
    var tokenFileUrl = 'https://example.com/satoshi.json';
    var expectedZoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';
    var actualZoneFile = (0, _lib.makeProfileZoneFile)(origin, tokenFileUrl);
    t.equal(actualZoneFile, expectedZoneFile);
  });
}

function testVerifyToken() {
  var tokenFile = _sampleData.sampleTokenFiles.ryan_apr20.body,
      token = tokenFile[0].token;

  var publicKey = "02413d7c51118104cfe1b41e540b6c2acaaf91f1e2e22316df7448fb6070d582ec",
      compressedAddress = "1BTku19roxQs2d54kbYKVTv21oBCuHEApF",
      uncompressedAddress = "12wes6TQpDF2j8zqvAbXV9KNCGQVF2y7G5";

  (0, _tape2.default)('verifyToken', function (t) {
    t.plan(3);

    var decodedToken1 = (0, _lib.verifyProfileToken)(token, publicKey);
    t.ok(decodedToken1, 'Token should have been verified against a public key');

    var decodedToken2 = (0, _lib.verifyProfileToken)(token, compressedAddress);
    t.ok(decodedToken2, 'Token should have been verified against a compressed address');

    var decodedToken3 = (0, _lib.verifyProfileToken)(token, uncompressedAddress);
    t.ok(decodedToken3, 'Token should have been verified against an uncompressed address');
  });
}

function testZoneFile() {
  (0, _tape2.default)('makeZoneFileForHostedProfile', function (t) {
    t.plan(3);

    var fileUrl = 'https://mq9.s3.amazonaws.com/naval.id/profile.json';
    var incorrectFileUrl = 'mq9.s3.amazonaws.com/naval.id/profile.json';
    var zoneFile = _lib.Profile.makeZoneFile('naval.id', fileUrl);
    t.ok(zoneFile, 'Zone file should have been created for hosted profile');
    t.ok(zoneFile.includes('"' + fileUrl + '"'), 'Zone file should include quoted entire profile url');
    t.notOk(zoneFile.includes('"' + incorrectFileUrl + '"'), 'Zone file should not include quoted profile url without protocol');
  });
}
function testSchemas() {
  var keyPair = new _bitcoinjsLib.ECPair.makeRandom({ rng: _lib.getEntropy });
  var privateKey = keyPair.d.toBuffer(32).toString('hex');
  var publicKey = keyPair.getPublicKeyBuffer().toString('hex');

  (0, _tape2.default)('Profile', function (t) {
    t.plan(5);

    var profileObject = new _lib.Profile(_sampleData.sampleProfiles.naval);
    t.ok(profileObject, 'Profile object should have been created');

    var validationResults = _lib.Profile.validateSchema(_sampleData.sampleProfiles.naval);
    t.ok(validationResults.valid, 'Profile should be valid');

    var profileJson = profileObject.toJSON();
    t.ok(profileJson, 'Profile JSON should have been created');

    var tokenRecords = profileObject.toToken(privateKey);
    t.ok(tokenRecords, 'Profile tokens should have been created');

    var profileObject2 = _lib.Profile.fromToken(tokenRecords, publicKey);
    t.ok(profileObject2, 'Profile should have been reconstructed from tokens');
  });

  (0, _tape2.default)('Person', function (t) {
    t.plan(18);

    var personObject = new _lib.Person(_sampleData.sampleProfiles.naval);
    t.ok(personObject, 'Person object should have been created');

    var validationResults = _lib.Person.validateSchema(_sampleData.sampleProfiles.naval, true);
    t.ok(validationResults.valid, 'Person profile should be valid');

    var token = personObject.toToken(privateKey);
    var tokenRecords = [(0, _lib.wrapProfileToken)(token)];
    t.ok(tokenRecords, 'Person profile tokens should have been created');
    //fs.writeFileSync('./docs/token-files/naval-4-tokens.json', JSON.stringify(tokenRecords, null, 2))

    var profileObject2 = _lib.Person.fromToken(tokenRecords[0].token, publicKey);
    t.ok(profileObject2, 'Person profile should have been reconstructed from tokens');

    var name = personObject.name();
    t.ok(name, 'Name should have been returned');
    t.equal(name, 'Naval Ravikant', 'Name should match the expected value');

    var givenName = personObject.givenName();
    t.ok(givenName, 'Given name should have been returned');
    t.equal(givenName, 'Naval', 'Given name should match the expected value');

    var familyName = personObject.familyName();
    t.ok(familyName, 'Family name should have been returned');
    t.equal(familyName, 'Ravikant', 'Family name should match the expected value');

    var description = personObject.description();
    t.ok(description, 'Avatar URL should have been returned');

    var avatarUrl = personObject.avatarUrl();
    t.ok(avatarUrl, 'Avatar URL should have been returned');

    var verifiedAccounts = personObject.verifiedAccounts([]);
    t.ok(verifiedAccounts, 'Verified accounts should have been returned');
    t.equal(verifiedAccounts.length, 0, 'Verified accounts should match the expected value');

    var address = personObject.address();
    t.ok(address, 'Address should have been returned');

    var birthDate = personObject.birthDate();
    t.ok(birthDate, 'Birth date should have been returned');

    var connections = personObject.connections();
    t.ok(connections, 'Connections should have been returned');

    var organizations = personObject.organizations();
    t.ok(organizations, 'Organizations should have been returned');
  });

  (0, _tape2.default)('legacyFormat', function (t) {
    t.plan(2);

    var profileObject = _lib.Person.fromLegacyFormat(_sampleData.sampleProfiles.navalLegacy);
    t.ok(profileObject, 'Profile object should have been created from legacy formatted profile');

    var validationResults = _lib.Person.validateSchema(profileObject.toJSON(), true);
    t.ok(validationResults, 'Profile should be in a valid format');
  });

  (0, _tape2.default)('resolveZoneFileToPerson', function (t) {
    t.plan(2);

    var zoneFile = "$ORIGIN ryan.id\n$TTL 3600\n_http._tcp IN URI 10 1 \"https://blockstack.s3.amazonaws.com/ryan.id\"\n";
    var ownerAddress = "19MoWG8u88L6t766j7Vne21Mg4wHsCQ7vk";
    _fetchMock2.default.get(_sampleData.sampleTokenFiles.ryan.url, _sampleData.sampleTokenFiles.ryan.body);

    (0, _lib.resolveZoneFileToPerson)(zoneFile, ownerAddress, function (profile) {
      t.ok(profile, 'Profile was extracted');
      t.equal(profile.name, "Ryan Shea", 'The profile was recovered with the expected value of the name field');
    });
  });

  (0, _tape2.default)('profileLookUp', function (t) {
    t.plan(2);

    var name = 'ryan.id';
    var zoneFileLookupURL = 'http://localhost:6270/v1/names/';

    var mockZonefile = {
      "zonefile": "$ORIGIN ryan.id\n$TTL 3600\n_http._tcp IN URI 10 1 \"https://blockstack.s3.amazonaws.com/ryan.id\"\n",
      "address": "19MoWG8u88L6t766j7Vne21Mg4wHsCQ7vk"
    };

    _fetchMock2.default.get('http://localhost:6270/v1/names/ryan.id', mockZonefile);
    _fetchMock2.default.get(_sampleData.sampleTokenFiles.ryan.url, _sampleData.sampleTokenFiles.ryan.body);

    (0, _lib.lookupProfile)(name, zoneFileLookupURL).then(function (profile) {
      t.ok(profile, 'zonefile resolves to profile');
      t.equal(profile.name, "Ryan Shea", 'The profile was recovered with the expected value of the name field');
    });
  });
}

function runProfilesUnitTests() {
  testVerifyToken();
  testTokening('naval.json', _sampleData.sampleProfiles.naval);
  testTokening('google.json', _sampleData.sampleProfiles.google);
  testTokening('balloonDog.json', _sampleData.sampleProfiles.balloonDog);
  testZoneFile();
  testSchemas();
}